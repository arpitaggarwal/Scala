{"name":"Scala","tagline":"Scala","body":"## Scala.Any\r\n* **Class Any is the root of the Scala class hierarchy**. Every class in a Scala execution environment inherits directly or \r\n  indirectly from this class.\r\n* Starting with Scala 2.10 it is possible to directly extend Any using universal traits. A universal trait is a trait that \r\n  extends Any, only has defs as members, and does no initialization.\r\n* The superclass of all classes **scala.Any has two direct subclasses scala.AnyVal and scala.AnyRef** representing two \r\n  different class worlds: **value classes and reference classes**.\r\n* All value classes are predefined; they correspond to the primitive types of Java-like languages. \r\n* All other classes define reference types. User-defined classes define reference types by default; i.e. they always  \r\n  (indirectly) subclass scala.AnyRef. \r\n* Every user-defined class in Scala implicitly extends the trait scala.ScalaObject. Classes from the infrastructure on \r\n  which Scala is running (e.g. the Java runtime environment) do not extend scala.ScalaObject. If Scala is used in the \r\n  context of a Java runtime environment, then scala.AnyRef corresponds to java.lang.Object.\r\n\r\n## Scala.AnyVal\r\n* AnyVal is the root class of all value types, which describe values not implemented as objects in the underlying host system.\r\n* The standard implementation includes nine AnyVal subtypes:\r\n     scala.Double, scala.Float, scala.Long, scala.Int, scala.Char, scala.Short, and scala.Byte are the numeric value types.\r\n     scala.Unit and scala.Boolean are the non-numeric value types.\r\n* Prior to Scala 2.10, AnyVal was a sealed trait. Beginning with Scala 2.10, however, it is possible to define a subclass \r\n  of AnyVal called a user-defined value class which is treated specially by the compiler. Properly-defined user value \r\n  classes provide a way to improve performance on user-defined types by avoiding object allocation at runtime, and by \r\n  replacing virtual method invocations with static method invocations.\r\n\r\nUser-defined value classes which avoid object allocation.\r\n* must have a single val parameter that is the underlying runtime representation.\r\n* can define defs, but no vals, vars, or nested traitss, classes or objects.\r\n* typically extend no other trait apart from AnyVal.\r\n* cannot be used in type tests or pattern matching.\r\n* may not override equals or hashCode methods.\r\nA minimal example:\r\n``` scala\r\nclass Wrapper(val underlying: Int) extends AnyVal {\r\n  def foo: Wrapper = new Wrapper(underlying * 19)\r\n}\r\n```\r\n\r\n## Scala.App\r\n* The App trait can be used to quickly turn objects into executable programs. Here is an example:\r\n``` scala\r\nobject Main extends App {\r\n  Console.println(\"Hello World: \" + (args mkString \", \"))\r\n}\r\n```\r\nHere, object Main inherits the main method of App. args returns the current command line arguments as an array.\r\n\r\n## Traits\r\n* A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class \r\n  inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits.\r\n* Traits are used to define object types by specifying the signature of the supported methods. Scala also allows traits to  \r\n  be partially implemented but traits may not have constructor parameters.\r\n* Child classes extending a trait can give implementation for the un-implemented methods. So a trait is very similar to \r\n  what we have abstract classes in Java.\r\n* A trait definition looks just like a class definition except that it uses the keyword trait as follows:\r\n\r\n``` scala\r\ntrait Equal {\r\n  def isEqual(x: Any): Boolean\r\n  def isNotEqual(x: Any): Boolean = !isEqual(x)\r\n}\r\n```\r\n###When to use traits?\r\n* There is no firm rule, but here are few guidelines to consider:\r\n* If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.\r\n* If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the \r\n  class hierarchy.\r\n* If you want to inherit from it in Java code, use an abstract class.\r\n* If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might   \r\n  lean towards using an abstract class.\r\n* If efficiency is very important, lean towards using a class.\r\n\r\n### Advantages of traits over Abstract classes?\r\n* We can use multiple traits -- they are \"stackable\". Also, traits cannot have constructor parameters. They will call each other from right to left. \r\n* Traits is that you can extend multiple traits but only one abstract class. Traits solve many of the problems with multiple inheritance but allow code reuse.\r\n\r\n``` scala\r\nclass Ball {\r\n  def properties(): List[String] = List()\r\n  override def toString() = \"It's a\" +\r\n    properties.mkString(\" \", \", \", \" \") +\r\n    \"ball\"\r\n}\r\n\r\ntrait Red extends Ball {\r\n  override def properties() = super.properties ::: List(\"red\")\r\n}\r\n\r\ntrait Shiny extends Ball {\r\n  override def properties() = super.properties ::: List(\"shiny\")\r\n}\r\n\r\nobject Balls {\r\n  def main(args: Array[String]) {\r\n    val myBall = new Ball with Shiny with Red\r\n    println(myBall) // It's a shiny, red ball\r\n  }\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}